theory android
begin

builtins: hashing

functions: xor/2, xor_inv/2, cbc_enc/3, cbc_dec/3, null/0, enc_int/2, dec_int/2

equations:
    xor_inv(xor(a, b), a) = b,
    xor_inv(xor(a, b), b) = a,
    xor(a, null) = a,
    dec_int(enc_int(m, k), k) = m,
    cbc_enc(m, c, k) = enc_int(xor(c, m), k),
    cbc_dec(cCurr, cPrev, k) = xor_inv(dec_int(cCurr, k), cPrev)


rule CBCEncrypt:
    let
    c1 = cbc_enc(head, ~c0, ~k) 
    in
    [
        CBCEncrypt(token, <head, tail>),
        Fr(~c0),
        Fr(~k)
    ]
    --[
        NotEq(head, null),
        NotEq(tail, null),
        CBCEncrypt_Check(),
        CBCEncrypt_Token(token),
        CBCEncrypt_Tail(tail)
    ]->
    [
        CBCEncryptIntermOut(token, <c1, ~c0, null>, tail, ~k)
    ]

rule CBCEncrypt_IntermidiateStep:
    let
    newBlock = cbc_enc(head, prevBlock, k)
    in
    [
        CBCEncryptIntermOut(token, <prevBlock, encryptedRest>, <head, tail>, k)
    ]
    --[
        NotEq(tail, null),
        CBCEncrypt_IntermidiateStep_Check(),
        CBCEncrypt_IntermidiateStep_Token(token),
        CBCEncrypt_IntermidiateStep_PrevBlock(prevBlock),
        CBCEncrypt_IntermidiateStep_NewBlock(newBlock),
        CBCEncrypt_IntermidiateStep_Head(head),
        CBCEncrypt_IntermidiateStep_Tail(tail)  
    ]->
    [
        CBCEncryptIntermOut(token, <newBlock, prevBlock, encryptedRest>, 
            tail, k)
    ]

rule CBCEncrypt_IntermidiateStep_Last:
    let
    lastEncryptedBlock = cbc_enc(head, prevBlock, k)
    in
    [
        CBCEncryptIntermOut(token, <prevBlock, encryptedRest>, <head, tail>, k)
    ]
    --[
        Eq(tail, null),
        CBCEncrypt_IntermidiateStep_Last_Check()
    ]->
    [
        CBCEncrypt_Result(token, k, <lastEncryptedBlock, prevBlock, 
            encryptedRest>)
    ]

/* CBC Decryption */

rule CBCDecrypt:
    let
    newDecrypted = cbc_dec(firstBlock, nextBlock, k)
    in
    [
        CBCDecrypt(token, k, <firstBlock, nextBlock, rest>)
    ]
    --[
        NotEq(firstBlock, null),
        NotEq(nextBlock, null),
        NotEq(rest, null),
        CBCDecrypt_Check()
    ]->
    [
        CBCDecryptIntermOut(token, <newDecrypted, null>, <nextBlock, rest>, k) 
    ]

rule CBCDecrypt_IntermidiateStep:
    let
    newDecrypted = cbc_dec(currBlock, previousBlock, k)
    in
    [
        CBCDecryptIntermOut(token, decryptedBlocks, <currBlock, previousBlock, 
            rest>, k)
    ]
    --[
        NotEq(currBlock, null),
        NotEq(previousBlock, null),
        NotEq(rest, null)
    ]->
    [
        CBCDecryptIntermOut(token, <newDecrypted, decryptedBlocks>,
            <previousBlock, rest>, k)
    ]

rule CBCDecrypt_IntermidiateStep_Last:
    let
    newDecrypted = cbc_dec(currBlock, previousBlock, k)
    in
    [
        CBCDecryptIntermOut(token, decryptedBlocks, <currBlock, previousBlock, 
            rest>, k)
    ]
    --[
        NotEq(currBlock, null),
        NotEq(previousBlock, null),
        Eq(rest, null),
        CBCDecrypt_IntermidiateStep_Last_Check()
    ]->
    [
        CBCDecrypt_Result(token, <newDecrypted, decryptedBlocks>)
    ]   

rule Scenario_EncryptCBC:
    [
        Fr(~token),
        Fr(~m1),
        Fr(~m2),
        Fr(~m3),
        Fr(~m4)
    ]
    --[
    ]->
    [
        CBCEncrypt(~token, <~m1, ~m2, ~m3, ~m4, null>),
        St_Scenario_EncryptCBC(~token)
    ]

rule Scenario_EncryptCBC_Result:
    [
        St_Scenario_EncryptCBC(token),
        CBCEncrypt_Result(token, k, encryptedBlocks) 
    ]
    --[
        Scenario_EncryptCBC_Result_Check()
    ]->
    [
        St_Scenario_EncryptCBC_Result(k, encryptedBlocks)
    ]

rule Scenario_DecryptCBC:
    [
        St_Scenario_EncryptCBC_Result(k, encryptedBlocks),
        Fr(~token)
    ]
    --[
        Scenario_DecryptCBC_Check()
    ]->
    [
        St_Scenario_DecryptCBC(~token),
        CBCDecrypt(~token, k, encryptedBlocks)
    ]

rule Attacker_ActivateOracle_Request:
    let 
    m1 = <h(~m1), ~m1, null>
    m2 = <h(~m2), ~m2, null>
    in
    [
        Fr(~token),
        Fr(~m1),
        Fr(~m2)
    ]
    --[
        Attacker_ActivateOracle_Request_Check()
    ]->
    [
        ActivateOracleRequest(~token, m1, m2),
        St_Attacker_ActivateOracle_Request(~token, m1, m2),
        St_Attacker_ActivateMessages(m1, m2)
    ]

rule ActivateOracle_FirstMessage:
    [
        ActivateOracleRequest(token, m1, m2)
    ]
    --[
        ActivateOracle_FirstMessage_Check(),
        ActivateOracle_FirstEncrypted(token)
    ]->
    [
        CBCEncrypt(token, <h(m1), m1>),
        St_ActivateOracle(token) 
    ]

rule ActivateOracle_SecondMessage:
    [
        ActivateOracleRequest(token, m1, m2)
    ]
    --[
        ActivateOracle_SecondMessage_Check(),
        ActivateOracle_SecondEncrypted(token)
    ]->
    [
        CBCEncrypt(token, <h(m2), m2>),
        St_ActivateOracle(token) 
    ]

rule ActivateOracle_Response:
    [
        St_ActivateOracle(token),
        CBCEncrypt_Result(token, k, encryptedBlocks)
    ]
    --[
        ActivateOracle_Response_Check(),
        ActivateOracle_Response_Token(token)
    ]->
    [
        !OracleKey(token, k),
        ActivateOracle_Result(token, encryptedBlocks)
    ]

rule Attacker_ActivateOracle_Response:
    let
    newCT = <c3, c2, c1, null>
    in
    [
        St_Attacker_ActivateOracle_Request(token, m1, m2),
        ActivateOracle_Result(token, <c3, c2, c1, c0, null>)
    ]
    --[
        Attacker_ActivateOracle_Response_Check()
    ]->
    [
        OracleDecrypt_Request(token, newCT)
    ]

rule OracleDecrypt_Request:
    [
        !OracleKey(token, key),
        OracleDecrypt_Request(token, newCT)
    ]
    -->
    [
        CBCDecrypt(token, key, newCT),
        St_OracleDecrypt_Request(token),
        St_AttackerDecrypt_Request(token)
    ]

rule OracleDecrypt_Response:
    [
        St_OracleDecrypt_Request(token),
        CBCDecrypt_Result(token, result)
    ]
    --[
        OracleDecrypt_Response_Check()
    ]->
    [
        OracleDecrypt_Response(token, result)
    ]

rule AttackerDecrypt_Response_FirstMessage:
    [
        OracleDecrypt_Response(token, result),
        St_AttackerDecrypt_Request(token),
        St_Attacker_ActivateMessages(m1, m2)
    ]
    --[
        AttackerDecryptFirst_Response_Check(),
        Eq(m1, result),
        AttackerGuessFirst(token)
    ]->
    []

rule AttackerDecrypt_Response_SecondMessage:
    [
        OracleDecrypt_Response(token, result),
        St_AttackerDecrypt_Request(token),
        St_Attacker_ActivateMessages(m1, m2)
    ]
    --[
        AttackerDecryptSecond_Response_Check(),
        Eq(m2, result),
        AttackerGuessSecond(token)
    ]->
    []

restriction Eq: 
    "All x y #i. Eq(x, y) @ #i ==> x = y"

restriction NotEq:
    "All x y #i. NotEq(x, y) @ #i ==> not (x = y)"

restriction CBCEncrypt_OnceForToken:
    "All token #i. CBCEncrypt_Token(token) @ #i ==>
    not (Ex #j. CBCEncrypt_Token(token) @ #j & not (#i = #j))"

lemma CBCEncryptInterm_Check:
    exists-trace
    "Ex #i. CBCEncrypt_Check() @ #i"

lemma CBCEncrypt_IntermidiateStep_Check:
    exists-trace
    "Ex #i. CBCEncrypt_IntermidiateStep_Check() @ #i"

lemma CBCEncrypt_IntermidiateStep_Last_Check:
    exists-trace
    "Ex #i. CBCEncrypt_IntermidiateStep_Last_Check() @ #i"

lemma Scenario_EncryptCBC_Result_Check:
    exists-trace
    "Ex #i. Scenario_EncryptCBC_Result_Check() @ #i"

lemma Scenario_DecryptCBC_Check:
    exists-trace
    "Ex #i. Scenario_DecryptCBC_Check() @ #i"

lemma CBCDecrypt_Check:
    exists-trace
    "Ex #i. CBCDecrypt_Check() @ #i"

lemma CBCDecrypt_IntermidiateStep_Last_Check:
    exists-trace
    "Ex #i. CBCDecrypt_IntermidiateStep_Last_Check() @ #i"

lemma Attacker_ActivateOracle_Request_Check:
    exists-trace
    "Ex #i. Attacker_ActivateOracle_Request_Check() @ #i"

lemma ActivateOracle_FirstMessage_Check:
    exists-trace
    "Ex #i. ActivateOracle_FirstMessage_Check() @ #i"

lemma ActivateOracle_SecondMessage_Check:
    exists-trace
    "Ex #i. ActivateOracle_SecondMessage_Check() @ #i"

lemma ActivateOracle_Response_Check:
    exists-trace
    "Ex #i. ActivateOracle_Response_Check() @ #i"

lemma Attacker_ActivateOracle_Response_Check:
    exists-trace
    "Ex #i. Attacker_ActivateOracle_Response_Check() @ #i"

lemma OracleDecrypt_Response_Check:
    exists-trace
    "Ex #i. OracleDecrypt_Response_Check() @ #i"

lemma AttackerDecryptFirst_Response_Check:
    exists-trace
    "Ex #i. AttackerDecryptFirst_Response_Check() @ #i"

lemma AttackerDecryptSecond_Response_Check:
    exists-trace
    "Ex #i. AttackerDecryptSecond_Response_Check() @ #i"

lemma ActivateOracle_OneTokenOneActivation [reuse]:
    "All token #i. ActivateOracle_Response_Token(token) @ #i ==>
    not (Ex #j. ActivateOracle_Response_Token(token) @ #j & not (#j = #i))"

lemma AttackerGuessFirst_OracleHasBeenActivated [reuse]:
    "All token #i. AttackerGuessFirst(token) @ #i ==>
    Ex #j. ActivateOracle_Response_Token(token) @ #j & #j < #i"

lemma AttackerGuessSecond_OracleHasBeenActivated [reuse]:
    "All token #i. AttackerGuessSecond(token) @ #i ==>
    Ex #j. ActivateOracle_Response_Token(token) @ #j & #j < #i"

lemma ActivateOracle_FirstEncrypted_EncryptionWithTokenOnlyOnce:
    "All token #i. ActivateOracle_FirstEncrypted(token) @ #i ==>
    not (Ex #j. ActivateOracle_SecondEncrypted(token) @ #j)"

lemma ActivateOracle_SecondEncrypted_EncryptionWithTokenOnlyOnce:
    "All token #i. ActivateOracle_SecondEncrypted(token) @ #i ==>
    not (Ex #j. ActivateOracle_FirstEncrypted(token) @ #j)"

lemma AttackerGuessFirst_AlwaysCorrect:
    "All token #i. AttackerGuessFirst(token) @ #i ==> 
    Ex #j. ActivateOracle_FirstEncrypted(token) @ #j & #j < #i"

lemma AttackerGuessSecond_AlwaysCorrect:
    "All token #i. AttackerGuessSecond(token) @ #i ==>
    Ex #j. ActivateOracle_SecondEncrypted(token) @ #j & #j < #i"

end
